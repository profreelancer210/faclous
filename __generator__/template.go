package main

const linterPredefinedVariables = `
// Code generated by __generator__/linter.go; DO NOT EDIT.

package context

import (
	"github.com/ysugimoto/falco/types"
)

func predefinedVariables() Variables {
	return {{ .Variables }}
}

func newRegexMatchedValues() map[string]int {
	return map[string]int{
		"re.group.0": 0,
		"re.group.1": 0,
		"re.group.2": 0,
		"re.group.3": 0,
		"re.group.4": 0,
		"re.group.5": 0,
		"re.group.6": 0,
		"re.group.7": 0,
		"re.group.8": 0,
		"re.group.9": 0,
		"re.group.10": 0,
	}
}`

const linterBuiltinFunctions = `
// Code generated by __generator__/linter.go; DO NOT EDIT.

package context

import (
	"github.com/ysugimoto/falco/types"
)

type Functions map[string]*FunctionSpec

type FunctionSpec struct {
	Items map[string]*FunctionSpec
	Value *BuiltinFunction
}

type BuiltinFunction struct {
	Arguments 						[][]types.Type
	Return    						types.Type
	Extra     						func(c *Context, name string) interface{}
	Scopes    						int
	Reference 						string
	IsUserDefinedFunction bool
}

func builtinFunctions() Functions {
	return {{ .Functions }}
}`

const simulatorPredefinedVariables = `
// Code generated by __generator__/simulator.go; DO NOT EDIT.

package variable

import (
	"github.com/ysugimoto/falco/simulator/types"
)

func PredefinedVariables() Variables {
	vs := Variables{}
	{{ .Variables }}
	return vs
}
`

const simulatorBuiltinFunctions = `
// Code generated by __generator__/simulator.go; DO NOT EDIT.

package function

import (
	"fmt"

	"github.com/pkg/errors"
	"github.com/ysugimoto/falco/simulator/context"
	"github.com/ysugimoto/falco/simulator/variable"
	"github.com/ysugimoto/falco/simulator/types"
)

type Function struct {
	Scope types.Scope
	Call  func(ctx *context.Context, args ...variable.Value) (variable.Value, error)
}

func Exists(name string, scope types.Scope) (Function, error) {
	fn, ok := builtinFunctions[name]
	if !ok {
		return Function{}, errors.WithStack(fmt.Errorf("Function %s is not defined", name))
	} else if (fn.Scope & scope) == 0 {
		return Function{}, errors.WithStack(fmt.Errorf("Function %s could not call on %s scope", name, scope.String()))
	}
	return fn, nil
}

var builtinFunctions = map[string]Function {
	{{ .Functions }}
}
`
